# -*- coding: utf-8 -*-
"""Agriculture_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11sgbfSeJqRRJSrSgfig7jjcEvczUWyOv

Import The Libraries
"""

import numpy as np
import pandas as pd
import pickle
import matplotlib.pyplot as plt
import plotly.express as px
import seaborn as sns
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.model_selection import train_test_split, cross_val_score

# Load the dataset
df = pd.read_csv('/content/crop_yield.csv')

df.shape

df = pd.read_csv('/content/crop_yield.csv',nrows=100000)

df.head()

df.tail()

df.columns

# Select relevant columns
df = df[['Soil_Type', 'Crop', 'Rainfall_mm', 'Temperature_Celsius',
         'Fertilizer', 'Irrigation_Used', 'Weather_Condition',
         'Days_to_Harvest', 'Fertilizer_Usage_Level']]

#Checking Null Values
df.isnull().sum()

df.duplicated().sum()

df['Crop'].value_counts()

"""Data Visualization"""

#Histogram
df.hist(bins=60, figsize =(20,10))
plt.show()

#Pie Chart
data = df['Crop'].value_counts().reset_index()
data.columns = ['Crop', 'Count']

fig = px.pie(data, names='Crop', values='Count', title='Crop Count')
fig.show()

#Scatter Plot
fig = px.scatter(df, x='Rainfall_mm', y='Fertilizer_Usage_Level',
                 title='Fertilizer_Usage vs Rainfall', labels={'Rainfall_mm': 'Rainfall (mm)', '': 'Fertilizer (Usage Level)'})
fig.show()

#pairplot
sns.pairplot(df,
             vars=['Rainfall_mm', 'Temperature_Celsius',
                   'Days_to_Harvest', 'Fertilizer_Usage_Level'])
plt.show()

#KDE
sns.kdeplot(df['Fertilizer_Usage_Level'], fill=True)
plt.title('Level of Fertilizer')
plt.show()

#Boxplot for checking outliers
plt.figure(figsize=(15,10))

for i,column in enumerate(['Rainfall_mm','Temperature_Celsius','Days_to_Harvest'],1):
  plt.subplot(3,3,i)
  # Removed the kde argument
  sns.boxplot(df[column])
  plt.title(f"Distributed of {column}")
plt.tight_layout()
plt.show()

# Countplot for categorical columns
sns.set()
categorical_columns = ['Soil_Type', 'Crop', 'Fertilizer', 'Irrigation_Used', 'Weather_Condition']
for col in categorical_columns:
    plt.figure(figsize=(5,5))
    sns.countplot(x=col, data=df)
    plt.title(f"Distribution of {col}")
    plt.show()

#correlation
df.corr(numeric_only=True)

#heatmap
sns.heatmap(df.corr(numeric_only=True),annot = True)

# Convert boolean column to str
df['Fertilizer'] = df['Fertilizer'].astype(str).replace({"True": 1, "False": 0})
df['Irrigation_Used'] = df['Irrigation_Used'].astype(str)

# Define features (X) and target (Y) Column
X = df.drop(columns=["Fertilizer"])
Y = df["Fertilizer"]

# Encoding categorical features
categorical_features = ['Soil_Type', 'Crop', 'Weather_Condition', 'Irrigation_Used']
encoder = OneHotEncoder(sparse_output=False, handle_unknown='ignore')
ct = ColumnTransformer(transformers=[('encoder', encoder, categorical_features)], remainder='passthrough')

X = ct.fit_transform(X)

# Split  dataset training and testing
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=1)

# Scale numeric columns
sc = StandardScaler()
X_train[:, -3:] = sc.fit_transform(X_train[:, -3:])
X_test[:, -3:] = sc.transform(X_test[:, -3:])

"""Model Training

Training with default hyperparameters
"""

# dictionary of models

models={
    "Decision Tree": DecisionTreeClassifier(random_state=0),
    "Random Forest": RandomForestClassifier(random_state=0)
}

# dictionary to store the cross validation results
cv_scores = {}

#perform 5-fold cross validation for each model
for model_name,model in models.items():
  print(f"Training {model_name} With default parameters")
  scores=cross_val_score(model,X_train,Y_train,cv=5,scoring="accuracy")
  cv_scores[model_name]=scores
  print(f"{model_name} cross-validation accuracy: {np.mean(scores):.2f}")

cv_scores

"""Random Forest gives The Highest Accuracy"""

# Train Random Forest Classifier
rfc = RandomForestClassifier(random_state=0)
rfc.fit(X_train, Y_train)

# Predict on training and test data
y_train_pred = rfc.predict(X_train)
y_test_pred = rfc.predict(X_test)

#evaluation on test data
from sklearn.metrics import classification_report, accuracy_score, confusion_matrix

y_test_pred=rfc.predict(X_test)

print("Accuracy Score :\n",accuracy_score(Y_test,y_test_pred))
print("Confusion Matrix :\n",confusion_matrix(Y_test,y_test_pred))
print("Classification Report :\n",classification_report(Y_test,y_test_pred))

"""Save The Model and Build Predictive System for the Problem Statement"""

# Save the trained model and transformer as pickle file
pickle.dump(rfc, open('random_forest.pkl', 'wb'))
pickle.dump(ct, open('column_transformer.pkl', 'wb'))

input_data = ['Sandy', 'Cotton', 897.077239110123, 27.6769663733776, True, 'Cloudy', 122, 6.55581625822359]
input_df = pd.DataFrame([input_data], columns=['Soil_Type', 'Crop', 'Rainfall_mm', 'Temperature_Celsius', 'Irrigation_Used', 'Weather_Condition', 'Days_to_Harvest', 'Fertilizer_Usage_Level'])

# Preprocess the input data using the same ColumnTransformer
# Convert 'Irrigation_Used' to string before transformation
input_df['Irrigation_Used'] = input_df['Irrigation_Used'].astype(str)
input_df_encoded = ct.transform(input_df)

input_df

input_df_encoded

prediction = rfc.predict(input_df_encoded)
print(prediction)

prediction[0]

# Display the result
if prediction[0] == 1:
    print("Prediction Result: Fertilizer Minimized")
else:
    print("Prediction Result: Fertilizer not Minimized")

filename='trained_model.RFC'
pickle.dump(rfc,open(filename,'wb'))

#loading the saved model
loaded_model=pickle.load(open('trained_model.RFC', 'rb'))

input_data=['Sandy','Cotton',897.077239110123,27.6769663733776,True,'Cloudy',122,6.55581625822359]
input_df=pd.DataFrame([input_data],columns=['Soil_Type', 'Crop', 'Rainfall_mm', 'Temperature_Celsius', 'Irrigation_Used', 'Weather_Condition', 'Days_to_Harvest', 'Fertilizer_Usage_Level'])

# Preprocess the input data using the same ColumnTransformer
# Convert 'Irrigation_Used' to string before transformation
input_df['Irrigation_Used'] = input_df['Irrigation_Used'].astype(str)
input_df_encoded = ct.transform(input_df)

prediction = loaded_model.predict(input_df_encoded)
print(prediction)

prediction = rfc.predict(input_df_encoded)
print("Prediction Result :", "Fertilizer minimized" if prediction[0] == 1 else "Fertilizer not Minimized")

"""Stream Lit"""

! pip install py-localtunnel

! npm install -g localtunnel

! pip install streamlit -q

# Commented out IPython magic to ensure Python compatibility.
# %%writefile Agriculturewebapp.py
# import numpy as np
# import pandas as pd
# import pickle
# import streamlit as st
# import matplotlib.pyplot as plt
# import seaborn as sns
# 
# # Load the trained model and ColumnTransformer
# loaded_model = pickle.load(open('random_forest.pkl', 'rb'))
# ct = pickle.load(open('column_transformer.pkl', 'rb'))
# 
# # Function for prediction
# def fertilize_min(input_data):
#     input_df = pd.DataFrame([input_data], columns=[
#         'Soil_Type', 'Crop', 'Rainfall_mm', 'Temperature_Celsius',
#         'Irrigation_Used', 'Weather_Condition', 'Days_to_Harvest', 'Fertilizer_Usage_Level'
#     ])
# 
#     input_df['Irrigation_Used'] = input_df['Irrigation_Used'].astype(str)
#     input_df_encoded = ct.transform(input_df)
#     prediction = loaded_model.predict(input_df_encoded)
# 
#     return "‚úÖ Fertilizer Minimized" if prediction[0] == 1 else "‚ùå Fertilizer not Minimized"
# 
# # Streamlit App
# def main():
#     st.title('üåø Agriculture Fertilizer Prediction')
# 
#     # Sidebar for dataset upload
#     st.sidebar.header("üìÇ Upload Dataset")
#     uploaded_file = st.sidebar.file_uploader("Upload CSV File", type=['csv'])
# 
#     if uploaded_file:
#         df = pd.read_csv(uploaded_file)
#         st.sidebar.success("Dataset Loaded Successfully ‚úÖ")
# 
#         # Display dataset preview
#         st.subheader("üìä Dataset Preview")
#         st.write(df.head())
# 
#         # Data Visualization
#         st.subheader("üìà Data Visualization")
# 
#         # Histogram
#         fig, ax = plt.subplots(figsize=(10, 5))
#         df.hist(bins=30, ax=ax)
#         st.pyplot(fig)
# 
#         # Scatter Plot
#         fig, ax = plt.subplots(figsize=(6, 4))
#         sns.scatterplot(data=df, x='Rainfall_mm', y='Fertilizer_Usage_Level', ax=ax)
#         plt.title('Yield vs Rainfall')
#         st.pyplot(fig)
# 
#         # Accuracy Score
#         st.subheader("‚úÖ Model Accuracy Score")
#         accuracy = 0.92  # Replace with actual computed accuracy
#         st.metric("Random Forest Model Accuracy", f"{accuracy * 100:.2f}%")
# 
#     st.subheader("üå± Input Parameters")
# 
#     #input fields
#     col1, col2 = st.columns(2)
# 
#     with col1:
#         Soil_Type = st.text_input('üü¢ Type of the Soil', max_chars=20)
#         Crop = st.text_input('üåæ Type of the Crop', max_chars=20)
#         Rainfall_mm = st.number_input('üåß Rainfall Level (mm)', min_value=0.0, format="%.2f")
#         Temperature_Celsius = st.number_input('üå° Temperature (¬∞C)', min_value=-50.0, format="%.2f")
# 
#     with col2:
#         Irrigation_Used = st.selectbox('üíß Irrigation Used', ['True', 'False'])
#         Weather_Condition = st.text_input('üå§ Weather Condition', max_chars=20)
#         Days_to_Harvest = st.number_input('üìÖ Days to Harvest', min_value=0, step=1)
#         Fertilizer_Usage_Level = st.number_input('üåæ Fertilizer (Usage Level)', min_value=0.0, format="%.2f")
# 
#     if st.button("üîç Check Fertilizer Usage"):
#         input_data = [Soil_Type, Crop, Rainfall_mm, Temperature_Celsius, Irrigation_Used, Weather_Condition, Days_to_Harvest, Fertilizer_Usage_Level]
#         fertilizer = fertilize_min(input_data)
#         st.success(fertilizer)
# 
# if __name__ == "__main__":
#     main()
#

#password for streamlit localtunnel
!curl ipv4.icanhazip.com

! streamlit run Agriculturewebapp.py & npx localtunnel --port 8501